using Acquire.Enums;
using Acquire.Forms;
using Acquire.Models;
using Acquire.Models.Interfaces;
using Acquire.NetworkModels;
using Acquire.Panels;
using SocketMessaging;
using SocketMessaging.Server;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Windows.Forms;

namespace Acquire.Frames
{
    public partial class AcquireSetupFrame : Form
    {
        #region Public Variables

        /// <summary>
        /// The list of players generated by this setup frame
        /// </summary>
        public List<IPlayer> Players { get; } = new List<IPlayer>();

        /// <summary>
        /// Whether or not we are starting the game
        /// </summary>
        public bool IsStarting { get; private set; }

        #endregion

        #region Private Member Variables

        // Whether this game already has a host
        private bool HasHost => hostPlayer?.IsHost() ?? false;

        // Whether the host player is a local player or not
        private bool IsHostLocal => hostPlayer?.GetPlayerType() == PlayerType.Local;

        // Who the host player is
        private PlayerSetupPanel hostPlayer;

        // The original size of this frame
        private readonly Size originalSize;

        // The size of the remote connection status window
        private const int remoteStatusWidth = 285;

        // The server we are hosting for this game
        private TcpServer hostServer;

        // The mapping of endpoint string to list of players from remote connection
        private readonly Dictionary<string, List<Player>> remotePlayers = new Dictionary<string, List<Player>>();

        #endregion

        /// <summary>
        /// Make a new frame and initialize all the components
        /// </summary>
        public AcquireSetupFrame()
        {
            InitializeComponent();
            originalSize = Size;
        }

        #region Event Handlers

        /// <summary>
        /// Gathers all the players from the PlayerSetupPanels, checks that they are valid, and starts the game
        /// </summary>
        /// 
        /// <param name="sender">The object sending the event</param>
        /// <param name="args">The arguments sent</param>
        private void StartButton_Click(object sender, EventArgs args)
        {
            if (!LoadPlayersList())
            {
                return;
            }

            List<IPlayer> players = GetPlayers();

            // Only continue if we have at least one player
            if (!players.Any())
            {
                MessageBox.Show(@"There are not enough players to start the game.", @"Not enough players", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // Make sure the user knows that there are only AI players
            if (players.All(p => p.Type == PlayerType.AI))
            {
                if (MessageBox.Show(@"There are no human players, is this ok?", @"No human players?", MessageBoxButtons.YesNo, MessageBoxIcon.Error) != DialogResult.Yes)
                {
                    return;
                }
            }

            // TODO: Remove this logic as a part of #4 (Adjust handling of "Remote Players")
            // Make sure we have a host if we have remote players
            if (players.Any(p => p.Type == PlayerType.Remote) && !HasHost)
            {
                MessageBox.Show(@"There are remote players listed but no host selected. Please select a host", @"No host selected", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // If there is a remote host, initiate the connection
            if (players.SingleOrDefault(p => p.Type == PlayerType.Remote && p.IsHost) is IRemotePlayer remoteHost)
            {
                RemoteConnectForm dialog = new RemoteConnectForm(remoteHost.Endpoint, players);
                // Handle player renames
                dialog.PlayerNameChanged += (id, name) => { ExecuteAgainstPlayer(p => { p?.SetName(name); }, id); };

                DialogResult result = dialog.ShowDialog();
                // Don't start the game if the prcoess didn't complete successfully
                if (result != DialogResult.OK)
                {
                    // Reset all the player names back to their originals
                    ExecuteAgainstPlayers(p => p.ResetName());
                    return;
                }

                // TODO: Do something with the dialog's list of players?
                //players = dialog.Players;
            }

            IsStarting = true;
            Close();
        }

        /// <summary>
        /// Handles the form closing
        /// </summary>
        /// 
        /// <param name="sender">The object sending the event</param>
        /// <param name="args">The arguments sent</param>
        private void AcquireSetupFrame_FormClosing(object sender, FormClosingEventArgs args)
        {
            // If windows is shutting down, close it.
            if (args.CloseReason == CloseReason.WindowsShutDown)
            {
                return;
            }

            // If we are trying to start
            if (IsStarting)
            {
                // Make sure the user really wants it
                if (MessageBox.Show(@"Are you sure you want to start?", @"Are you sure?", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
                {
                    args.Cancel = true;
                    IsStarting = false;
                }
            }
            // Otherwise only close it if the user wants to.
            else if (MessageBox.Show(@"Are you sure you want to quit?", @"Are you sure?", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
            {
                args.Cancel = true;
            }
        }

        /// <summary>
        /// Handles event where a player is either claiming or releasing hosting rights for this game
        /// </summary>
        ///
        /// <param name="sender">The panel sending the event</param>
        /// <param name="isHost">Whether the sending panel is trying to claim host of this game</param>
        ///
        /// <returns>True if the panel successfully claimed or released hosting rights, false otherwise</returns>
        private bool PlayerSetupPanel_PlayerHostStatusChanged(PlayerSetupPanel sender, bool isHost)
        {
            // Don't allow another player to try to be host but if the same player
            // calls this event again, just let them pass through
            if (HasHost && isHost)
            {
                UpdateServerButtonState();
                return hostPlayer.PlayerId == sender.PlayerId;
            }

            if (isHost)
            {
                hostPlayer = sender;
            }
            else if (hostPlayer.PlayerId == sender.PlayerId)
            {
                hostPlayer = null;
            }

            UpdateServerButtonState();
            return true;
        }

        /// <summary>
        /// Handles opening the server connection panel and begins listening for remote connections
        /// </summary>
        ///
        /// <param name="sender">The object that initiated the event</param>
        /// <param name="e">The event args</param>
        private void OpenServerButton_Click(object sender, EventArgs e)
        {
            // Make sure we have a list of players to broadcast
            if (!LoadPlayersList())
            {
                return;
            }

            MaximumSize = new Size(Size.Width + remoteStatusWidth, Size.Height);
            Size = MaximumSize;
            MinimumSize = MaximumSize;
            OpenServerButton.Enabled = false;
            ExecuteAgainstPlayers(p => { p.SetJoinEnabled(false); });

            // Begin listening
            IPEndPoint endpoint = hostPlayer.GetAddressEndPoint();

            try
            {
                hostServer = new TcpServer();
                hostServer.Connected += Server_Connected;
                hostServer.Start(endpoint.Port);
                AddRemoteStatusMessage($"Listening for new connections on {endpoint.Address}:{endpoint.Port}");
            }
            catch (Exception ex)
            {
                AddRemoteStatusMessage($"Error when trying to open server connection: {ex.Message}");
            }
        }

        /// <summary>
        /// Handles a new remote connection being established to this server
        /// </summary>
        ///
        /// <param name="sender">The object that initiated the event</param>
        /// <param name="e">The event args</param>
        private void Server_Connected(object sender, ConnectionEventArgs e)
        {
            // Update the UI
            if (e.Connection.Socket.RemoteEndPoint is IPEndPoint endpoint)
            {
                AddRemoteStatusMessage($"Received new connection from {endpoint.Address}:{endpoint.Port}");
            }
            else
            {
                AddRemoteStatusMessage("Received new connection from unsupported endpoint, disconnecting");
                e.Connection.Close();
                return;
            }

            // Set up events for receiving messages and disconnects from client
            e.Connection.ReceivedMessage += Connection_ReceivedMessage;
            e.Connection.Disconnected += Connection_Disconnected;
            // TODO: Remove these when moving on to the actual game

            // Set up the connection to use our expected format
            e.Connection.SetDelimiter('|');
            e.Connection.SetMode(MessageMode.PrefixedLength);

            // Send the connection response message
            SendMessage(e.Connection, MessageType.Connect);
        }

        /// <summary>
        /// Handles receiving a message from a remote connection
        /// </summary>
        ///
        /// <param name="sender">The object that initiated the event</param>
        /// <param name="e">The event args</param>
        private void Connection_ReceivedMessage(object sender, EventArgs e)
        {
            Connection connection = sender as Connection;
            Debug.Assert(connection != null);

            NetworkMessage message = Utilities.GetMessageFromConnection<NetworkMessage>(connection);
            switch (message.MessageType)
            {
                case MessageType.PlayerListResponse:
                    HandlePlayerListResponse(message.Data as PlayerList, connection);
                    break;
                default:
                    RemoteStatusBox.Items.Add($"ERROR: Received unknown message type! `{message.MessageType}`");
                    break;
            }
        }

        /// <summary>
        /// Handles the player list response data
        /// </summary>
        ///
        /// <param name="message">The player list response message</param>
        /// <param name="connection">The connection the message came from</param>
        private void HandlePlayerListResponse(PlayerList message, Connection connection)
        {
            List<Player> newPlayers = message?.Players;
            if (newPlayers == null)
            {
                RemoteStatusBox.Items.Add($"ERROR: Received invalid player list from {GetEndPointId(connection.Socket.RemoteEndPoint as IPEndPoint)}, disconnecting");
                connection.Close();
                return;
            }

            // Negotiate player limits
            int playerCount = remotePlayers.Count + Players.Count;
            if (playerCount + newPlayers.Count > Game.MAX_PLAYERS)
            {
                string tooManyMessage = $"The {newPlayers.Count} added to the {playerCount} existing exceeds the maximum of {Game.MAX_PLAYERS}";
                RemoteStatusBox.Items.Add($"Received too many players from {GetEndPointId(connection.Socket.RemoteEndPoint as IPEndPoint)}, disconnecting. {tooManyMessage}");
                // Send rejection message
                SendMessage(connection, MessageType.Disconnect, new Disconnect
                {
                    Message = tooManyMessage
                });
                connection.Close();
                return;
            }

            // Negotiate player names
            List<string> playerNames = remotePlayers.Values.SelectMany(p => p.Select(rp => rp.Name)).Concat(Players.Select(p => p.Name)).ToList();
            List<Player> duplicateNames = newPlayers.Where(p => playerNames.Any(rpn => rpn.Equals(p.Name, StringComparison.OrdinalIgnoreCase))).ToList();
            if (duplicateNames.Any())
            {
                PlayerRename renames = new PlayerRename();

                // Generate list of names that need to be replaced
                foreach (Player player in duplicateNames)
                {
                    string newName = Utilities.GetUniqueName(player.Name, playerNames);
                    playerNames.Add(newName);

                    renames.PlayerRenames.Add(new PlayerRenameItem
                    {
                        PlayerId = player.PlayerId,
                        OriginalName = player.Name,
                        NewName = newName
                    });
                }
                SendMessage(connection, MessageType.PlayerRename, renames);
                return;
            }

            // Save the players list
            remotePlayers[GetEndPointId(connection.Socket.RemoteEndPoint as IPEndPoint)] = newPlayers;

            // Broadcast full players list to every connected client
            foreach (Connection clientConnection in hostServer.Connections)
            {
                SendMessage(clientConnection, MessageType.PlayerListResponse, new PlayerList
                {
                    Players = GetAdjustedPlayersList(clientConnection)
                });
            }
        }

        /// <summary>
        /// Handles disconnection of remote connections
        /// </summary>
        ///
        /// <param name="sender">The object that initiated the event</param>
        /// <param name="e">The event args</param>
        private void Connection_Disconnected(object sender, EventArgs e)
        {
            Connection connection = (Connection)sender;
            if (connection.Socket.RemoteEndPoint is IPEndPoint endpoint)
            {
                string endpointId = GetEndPointId(endpoint);
                AddRemoteStatusMessage($"Lost connection from {endpointId}");
                remotePlayers.Remove(endpointId);
            }
        }

        /// <summary>
        /// Handles closing the server connection panel and stops listening for remote connections
        /// </summary>
        ///
        /// <param name="sender">The object that initiated the event</param>
        /// <param name="e">The event args</param>
        private void CloseServerButton_Click(object sender, EventArgs e)
        {
            MinimumSize = originalSize;
            Size = originalSize;
            MaximumSize = originalSize;
            OpenServerButton.Visible = true;
            OpenServerButton.Enabled = true;
            // TODO: When #13 is implemented (Fake PSPs in ASF to represent remote players), this will need to be adjusted so they stay disabled
            ExecuteAgainstPlayers(p => { p.SetJoinEnabled(true); });

            // Stop listening
            if (hostServer != null)
            {
                hostServer.Connected -= Server_Connected;
                RemoteStatusBox.Items.Add("Stopped listening for new connections");
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Sends the given <paramref name="data"/> of type <paramref name="type"/> to the specified <paramref name="client"/>
        /// </summary>
        ///
        /// <param name="client">The client to send the message to</param>
        /// <param name="type">The type of message being sent</param>
        /// <param name="data">The message to send</param>
        private static void SendMessage(Connection client, MessageType type, AcquireNetworkModel data = null)
        {
            Utilities.SendMessageToConnection(client, data, type);
        }

        /// <summary>
        /// Adds a message to the remote status message panel
        /// </summary>
        ///
        /// <param name="message">The message to display</param>
        private void AddRemoteStatusMessage(string message)
        {
            Utilities.InvokeOnControl(RemoteStatusBox, () => RemoteStatusBox.Items.Add(message));
        }

        /// <summary>
        /// Generates a list of players connected to this server, adjusted so that <paramref name="client"/>'s players are shown as <seealso cref="PlayerType.Local"/> and playesr local to the server are shown as <seealso cref="PlayerType.Remote"/>
        /// </summary>
        ///
        /// <param name="client">The client that this list is being sent to</param>
        ///
        /// <returns>The generated list of adjusted players</returns>
        private List<Player> GetAdjustedPlayersList(Connection client)
        {
            List<Player> players = new List<Player>();
            foreach (IPlayer player in Players)
            {
                // Change the local players for the destination client to be "remote"
                if (player.Type == PlayerType.Local)
                {
                    players.Add(new RemotePlayer(player.PlayerId, hostPlayer.GetAddress(), player.IsHost, player.Name));
                }
                // Change the remote players for the destination client to be "local"
                else if (player.Type == PlayerType.Remote && IsPlayerFromConnection(player as RemotePlayer, client.Socket.RemoteEndPoint as IPEndPoint))
                {
                    players.Add(new Player(player.Name, PlayerType.Local, player.PlayerId, player.IsHost));
                }
                else
                {
                    players.Add(player as Player);
                }
            }

            return players;
        }

        /// <summary>
        /// Determines whether the given <paramref name="player"/> is from the specified <paramref name="endpoint"/>
        /// </summary>
        ///
        /// <param name="player">The player to check</param>
        /// <param name="endpoint">The endpoint to check</param>
        ///
        /// <returns>True if the <paramref name="player"/> is from the <paramref name="endpoint"/>, false otherwise</returns>
        private static bool IsPlayerFromConnection(IRemotePlayer player, IPEndPoint endpoint)
        {
            if (player?.Endpoint == null || endpoint == null)
            {
                return false;
            }

            return player.Endpoint.Address.Equals(endpoint.Address) &&
                   player.Endpoint.Port == endpoint.Port;
        }

        /// <summary>
        /// Gets a string representation of the <paramref name="endpoint"/>
        /// </summary>
        ///
        /// <param name="endpoint">The endpoint generate a string for</param>
        ///
        /// <returns>The string representation of the <paramref name="endpoint"/></returns>
        private static string GetEndPointId(IPEndPoint endpoint) => $"{endpoint.Address}:{endpoint.Port}";

        /// <summary>
        /// Gets the list of all the currently connected players
        /// </summary>
        ///
        /// <returns>The list of all the currently connected players</returns>
        private List<IPlayer> GetPlayers() => new List<IPlayer>(Players).Concat(remotePlayers.SelectMany(d => d.Value)).ToList();

        /// <summary>
        /// Loads the list of local players from the created player panels
        /// </summary>
        ///
        /// <returns>True if there were not errors, false if there were</returns>
        private bool LoadPlayersList()
        {
            // Clear the current list of players
            Players.Clear();
            // The list of current player names (to eliminate duplicates)
            List<string> playerNames = new List<string>();

            return ExecuteAgainstPlayers(panel =>
            {
                // If we are not joining, continue
                if (!panel.IsJoining())
                {
                    return true;
                }

                // Check if the player is ready
                if (!panel.IsReady())
                {
                    // Tell the user who isn't ready
                    if (panel.GetPlayerType() != PlayerType.AI)
                    {
                        MessageBox.Show($@"{panel.GetName()} is not ready yet.", @"Player not ready", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    else
                    {
                        MessageBox.Show(@"AI Player is not set to ready yet.", @"AI not set to ready", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }

                    return false;
                }

                // Get a unique form of this player's name
                string name = Utilities.GetUniqueName(panel.GetName(), playerNames);

                // Add this name to the list of names used
                playerNames.Add(name);

                // Create the player of the correct type
                Players.Add(panel.GetPlayer(name));

                return true;
            });
        }

        /// <summary>
        /// Executes the given <paramref name="method"/> against all of the <see cref="PlayerSetupPanel"/> objects in this frame.
        /// </summary>
        ///
        /// <param name="method">The method to execute</param>
        private void ExecuteAgainstPlayers(Action<PlayerSetupPanel> method)
        {
            ExecuteAgainstPlayers(p =>
            {
                method(p);
                return true;
            });
        }

        /// <summary>
        /// Executes the given <paramref name="method"/> against all of the <see cref="PlayerSetupPanel"/> objects in this frame.
        /// </summary>
        ///
        /// <param name="method">The method to execute</param>
        ///
        /// <returns>True if all calls to the <paramref name="method"/> return true, false otherwise</returns>
        private bool ExecuteAgainstPlayers(Func<PlayerSetupPanel, bool> method)
        {
            // Order the panels by name so the order that they show up in the frame corresponds to the order they are processed in
            IEnumerable<PlayerSetupPanel> setupPanels = Controls.OfType<PlayerSetupPanel>().OrderBy(p => p.Name);
            return setupPanels.Aggregate(true, (current, panel) => current && method(panel));
        }

        /// <summary>
        /// Executes the given <paramref name="method"/> against the <see cref="PlayerSetupPanel"/> that has the provided <paramref name="playerId"/>.
        /// </summary>
        ///
        /// <param name="method">The method to execute</param>
        /// <param name="playerId">The unique identifier for the player panel to execute the <paramref name="method"/> against</param>
        private void ExecuteAgainstPlayer(Action<PlayerSetupPanel> method, string playerId)
        {
            PlayerSetupPanel panel = Controls.OfType<PlayerSetupPanel>().FirstOrDefault(p => p.PlayerId == playerId);
            method(panel);
        }

        /// <summary>
        /// Updates the state of the server button, closing the dialog if the state changes while it is open
        /// </summary>
        private void UpdateServerButtonState()
        {
            // If this isn't a local host, update the server button and window status
            if (!IsHostLocal)
            {
                if (CloseServerButton.Enabled)
                {
                    CloseServerButton.PerformClick();
                }
                OpenServerButton.Visible = false;
                OpenServerButton.Enabled = false;
            }
            else
            {
                OpenServerButton.Visible = true;
                OpenServerButton.Enabled = true;
            }
        }

        #endregion
    }
}
